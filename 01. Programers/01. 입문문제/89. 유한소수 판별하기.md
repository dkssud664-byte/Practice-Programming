# 저주의 숫자 3

링크 : https://school.programmers.co.kr/learn/courses/30/lessons/120878


### 문제 설명

소수점 아래 숫자가 계속되지 않고 유한개인 소수를 유한소수라고 합니다. 분수를 소수로 고칠 때 유한소수로 나타낼 수 있는 분수인지 판별하려고 합니다. 유한소수가 되기 위한 분수의 조건은 다음과 같습니다.

-   기약분수로 나타내었을 때, 분모의 소인수가 2와 5만 존재해야 합니다.

두 정수  `a`와  `b`가 매개변수로 주어질 때, a/b가 유한소수이면 1을, 무한소수라면 2를 return하도록 solution 함수를 완성해주세요.

##### 제한사항
-   `a`,  `b`는 정수
-   0 <  `a` ≤ 1,000
-   0 <  `b` ≤ 1,000

##### 입출력 예
|A|B|result|
|---|---|---|
|7|20|1|
|11|22|1|
|12|21|2|


---
**실행 1(실패)**
기약소수로 만들고 소수에 2나 5가있으면 1 아니면 2를 반환하게 했다.


테스트 1, 4, 8, 28, 29, 33, 35, 38, 47, 48이 실패했다

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace C__연습
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(solution(7, 20));
        }

        static public int solution(int a, int b)
        {
            int answer = 0;
            bool isFind = false;
            int gcd = GCD(a, b);

            a /= gcd;
            b /= gcd;

            for(int i = 2; i <= b; i++)
            {
                if(b % i == 0)
                {
                    if(i == 2 || i == 5)
                    {
                        isFind = true;
                        break;
                    }
                    else if(i > 5)
                    {
                        break;
                    }
                }
            }

            return answer = isFind ? 1 : 2;
        }

        static int GCD(int x, int y)
        {
            while(y != 0)
            {
                int temp = y;
                y = x % y;
                x = temp;
            }
            return x;
        }
    }
}
```

---
**실행 2(실패)**

분모의 최대공약수를 구해서 분모의 소인수에 2가 있다면 2를 나누고 그다음 5가 있다면 5를 나눠서 분모가 1이 된다면 유한소수라고 판단했다.

하지만 4, 8번 케이스가 실패했다


```csharp
using System;

namespace C__연습
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(solution(7, 20));
        }

        static public int solution(int a, int b)
        {
            int answer = 0;
            bool isFind = false;
            int gcd = GCD(a, b);

            b /= gcd;

            while(true)
            {
                if(b % 2 == 0)
                {
                    b /= 2;
                }
                else if (b % 5 == 0)
                {
                    b /= 5;
                }
                else
                {
                    break;
                }

                if (b == 1)
                {
                    isFind = true;
                    break;
                }
            }

            return answer = isFind ? 1 : 2;
        }

        static int GCD(int x, int y)
        {
            while(y != 0)
            {
                int temp = y;
                y = x % y;
                x = temp;
            }
            return x;
        }
    }
}
```


---
**실행 3(성공)**
while문 안의 유한소수시 탈출조건을 최상위로 올려줬다.

```csharp
using System;

public class Solution {
    public int solution(int a, int b) {
        int answer = 0;
        bool isFind = false;
        int gcd = GCD(a, b);

        b /= gcd;

        while(true)
        {
            if (b == 1)
            {
                isFind = true;
                break;
            }
            
            if(b % 2 == 0)
            {
                b /= 2;
            }
            else if (b % 5 == 0)
            {
                b /= 5;
            }
            else
            {
                break;
            }
        }

        return answer = isFind ? 1 : 2;
    }
    
    int GCD(int x, int y)
    {
        while(y != 0)
        {
            int temp = y;
            y = x % y;
            x = temp;
        }
        return x;
    }
}
```
---
**후기**

코드의 순서가 중요하다는 것을 다시 한 번 상기하게 되었다.