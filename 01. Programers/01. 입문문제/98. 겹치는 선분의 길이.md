

# 겹치는 선분의 길이

링크 : https://school.programmers.co.kr/learn/courses/30/lessons/120876
선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열  `lines`가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요.

`lines`가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다.

![line_2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e4122d8b-9ce2-49ce-a360-3d1284babd8a/line_2.png)

선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1]로 길이 2만큼 겹쳐있습니다.

----------

##### 제한사항

-   `lines`의 길이 = 3
-   `lines`의 원소의 길이 = 2
-   모든 선분은 길이가 1 이상입니다.
-   `lines`의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다.
    -   -100 ≤ a < b ≤ 100

----------

##### 입출력 예
|lines|result|
|-|-|
|[[0, 1], [2, 5], [3, 9]]|2|
|[[-1, 1], [1, 3], [3, 9]]|0|
|[[0, 5], [3, 9], [1, 10]]|8|

---
**실행 1(실패)**

생각 : 겹치는 선이 있는지 판단하기 위해 비교할 선분 끝점이 비교당하는 선분 내에 있는지 판단 후 길이를 더한다.

![겹치는 선분](https://github.com/dkssud664-byte/Practice-Programming/blob/main/01.%20Programers/01.%20%EC%9E%85%EB%AC%B8%EB%AC%B8%EC%A0%9C/Images/98.%20%EA%B2%B9%EC%B9%98%EB%8A%94%20%EC%84%A0%EB%B6%84.png)
3번 테스트 케이스는 총 8칸이다.


실패 이유 : 겹칠때를 판달할때 선의 좌표가 같다면도 포함시켰다. 칸의 개념으로 넓이를 구해야하고 선 3개가 다 겹치더라도 1번만 포함해야 한다.

```csharp
using System;

public class Solution {
    public int solution(int[,] lines)
    {
        int answer = 0;

        //조건 범위 -100 ≤ a < b ≤ 100을 배열로 생각
        int[] lineArray = new int[201];

        //선의 범위만큼 +1을 기입
        for(int i = 0; i < lines.GetLength(0); i++)
        {
            for(int j = lines[i, 0]; j <= lines[i, 1]; j++)
            {
                lineArray[j + 100]++;
            }
        }

        //배열의 값이 2이상이라면 겹쳐있다
        foreach(int i in lineArray)
        {
            if(i >= 2)
            {
                answer++;
            }
        }

        return answer;
    }
}
```

---
**실행 2(실패)**

생각 : 실패이유를 생각하며 칸의 개념으로 배열을 순회했다.

결과 : 테스트 케이스 3, 7번이 틀렸다

실패 이유 : 질문목록을 보고
lines = new int[,] { { 1, 2 }, { 2, 3 }, { 3, 4 } };
케이스가 틀렸다는 것을 알았다.

```csharp
public int solution(int[,] lines)
        {
            int answer = 0;

            //조건 범위 -100 ≤ a < b ≤ 100을 배열로 생각
            int[] lineArray = new int[201];

            int count = 0;

            
            //선의 범위만큼 +1을 기입
            for(int i = 0; i < lines.GetLength(0); i++)
            {
                for(int j = lines[i, 0]; j <= lines[i, 1]; j++)
                {
                    lineArray[j + 100]++;
                }
            }

            //값이 2이상이면 겹친 좌표
            for(int i = 0; i < lineArray.Length; i++)
            {
                if(lineArray[i] > 1)
                {
                    count++;
                }
                else
                {
                    count = 0;
                }

                if (count > 1)
                {
                    answer++;
                }
            }

            return answer;
        }
```

---
**실행 3(성공)**

생각 : 끝 점을 제외한 선의 범위만큼만 +1한다

```csharp
using System;

public class Solution {
    public int solution(int[,] lines)
    {
        int answer = 0;

        //조건 범위 -100 ≤ a < b ≤ 100을 배열로 생각
        int[] lineArray = new int[201];


        //끝 점을 제외한 선의 범위만큼 +1을 기입
        for (int i = 0; i < lines.GetLength(0); i++)
        {
            for (int j = lines[i, 0]; j < lines[i, 1]; j++)
            {
                lineArray[j + 100]++;
            }
        }

        //값이 2이상이면 겹친 좌표
        for(int i = 0; i < lineArray.Length; i++)
        {
            if (lineArray[i] > 1)
            {
                answer++;
            }
        }

        return answer;
    }
}
```

---
**후기**
처음부터 예외처리를 잘 생각하고 구조를 만들어야했는데 미처 생각하지 못 했다.

하지만 처음부터 잘 생각하고 만들었더라도 생각에 미치지 못 했을 것 같다.

이번 기회로 배운것에 만족하자