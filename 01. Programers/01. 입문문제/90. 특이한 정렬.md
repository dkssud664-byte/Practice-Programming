# 특이한 정렬

링크 : https://school.programmers.co.kr/learn/courses/30/lessons/120880

정수  `n`을 기준으로  `n`과 가까운 수부터 정렬하려고 합니다. 이때  `n`으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치합니다. 정수가 담긴 배열  `numlist`와 정수  `n`이 주어질 때  `numlist`의 원소를  `n`으로부터 가까운 순서대로 정렬한 배열을 return하도록 solution 함수를 완성해주세요.

----------

##### 제한사항

-   1 ≤  `n`  ≤ 10,000
-   1 ≤  `numlist`의 원소 ≤ 10,000
-   1 ≤  `numlist`의 길이 ≤ 100
-   `numlist`는 중복된 원소를 갖지 않습니다.

----------

##### 입출력 예

|numlist|n|result|
|---|---|---|
|[1, 2, 3, 4, 5, 6]|4|[4, 5, 3, 6, 2, 1]|
|[10000,20,36,47,40,6,10,7000]|30|[36, 40, 20, 47, 10, 6, 7000, 10000]|


---
**실행 1(실패)**
n과 배열의 값을 차를 다른 배열에 넣어놓고 차이가 작은것부터 순서대로 answer에 넣는다

IndexOf()를 쓰면 간단할것 같았지만 버블정렬에 익숙해질겸 사용을 안했다.

버블 정렬 후 음수를 다시 절대값으로 계산해서 정렬 하고 인덱스를 넣어주면 된다고 생각했다.

하지만 문제를 잘 못 이해했다.

n과 가까운 numlist를 각각 몇 번째가까운지를 넣어주는지 알았는데 자세히 보니 정렬하는 것이었다.

```csharp
using System;
using System.Collections.Generic;
using System.IO.Pipes;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace C_연습
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] ints = { 1, 2, 3, 4, 5, 6 };

            int[] resutl = solution(ints, 4);

            foreach(int i in resutl)
            {
                Console.Write(i);
                Console.Write(" ");
            }
        }


        static public int[] solution(int[] numlist, int n)
        {
            int[] answer = new int[numlist.Length];
            int[] diff = new int[numlist.Length];
            int[] diffSort = new int[numlist.Length];

            for(int i = 0; i < numlist.Length; i++)
            {
                diff[i] = numlist[i] - n;
            }

            diffSort = (int[])diff.Clone();

            //버블정렬
            for(int i = 0; i < diffSort.Length - 1; i++)
            {
                bool isSwap = false;

                for (int j = 0; j < diffSort.Length - 1 - i; j++)
                {
                    if (diffSort[j] > diffSort[j + 1])
                    {
                        int temp = diffSort[j];
                        diffSort[j] = diffSort[j + 1];
                        diffSort[j + 1] = temp;
                        isSwap = true;
                    }
                }
                if(!isSwap)
                {
                    break;
                }
            }

            //음수가 있으면 다시 정렬
            for (int i = 0; i < diffSort.Length - 1; i++)
            {
                bool isSwap = false;

                for (int j = 0; j < diffSort.Length - 1 - i; j++)
                {
                    if (Math.Abs(diffSort[j]) >= diffSort[j + 1])
                    {
                        int temp = diffSort[j];
                        diffSort[j] = diffSort[j + 1];
                        diffSort[j + 1] = temp;
                        isSwap = true;
                    }
                }
                if (!isSwap)
                {
                    break;
                }
            }

            //인덱스 순서 넣기
            for(int i = 0; i < diff.Length; i++)
            {
                for(int j = 0; j < diffSort.Length; j++)
                {
                    if (diffSort[j] == diff[i])
                    {
                        answer[i] = j;
                        break;
                    }
                }
            }

            return answer;
        }
    }
}
```
---
**실행 2(실패)**

그래도 n과 가까운 인덱스 번호는 구했으니 여기에 실제 값만 넣어주면 된다고 생각했다.

테스트 2가 실패가 떴다.
```csharp
using System;

public class Solution {
    public int[] solution(int[] numlist, int n) {
        int[] answer = new int[numlist.Length];
        int[] diff = new int[numlist.Length];
        int[] diffSort = new int[numlist.Length];

        for(int i = 0; i < numlist.Length; i++)
        {
            diff[i] = numlist[i] - n;
        }

        diffSort = (int[])diff.Clone();

        //버블정렬
        for(int i = 0; i < diffSort.Length - 1; i++)
        {
            bool isSwap = false;

            for (int j = 0; j < diffSort.Length - 1; j++)
            {
                if (diffSort[j] > diffSort[j + 1])
                {
                    int temp = diffSort[j];
                    diffSort[j] = diffSort[j + 1];
                    diffSort[j + 1] = temp;
                    isSwap = true;
                }
            }
            if(!isSwap)
            {
                break;
            }
        }

        //음수가 있으면 다시 정렬
        for (int i = 0; i < diffSort.Length - 1; i++)
        {
            bool isSwap = false;

            for (int j = 0; j < diffSort.Length - 1 - i; j++)
            {
                if (diffSort[j] < 0 && Math.Abs(diffSort[j]) >= diffSort[j + 1] )
                {
                    int temp = diffSort[j];
                    diffSort[j] = diffSort[j + 1];
                    diffSort[j + 1] = temp;
                    isSwap = true;
                }
            }
            if (!isSwap)
            {
                break;
            }
        }

        //값 넣기
        for(int i = 0; i < diff.Length; i++)
        {
            for(int j = 0; j < diffSort.Length; j++)
            {
                if (diffSort[j] == diff[i])
                {
                    answer[j] = numlist[i];
                    break;
                }
            }
        }

        return answer;
    }
}

```

---
**실행 3(성공)**

음수를 절대값으로 정렬할때 같은 음수끼리의 비교에서 오류가 있었다.

음수를 둘다 양수로 바꾸어 비교를 했어야 했다.

```csharp
using System;

public class Solution {
    public int[] solution(int[] numlist, int n) {
        int[] answer = new int[numlist.Length];
        int[] diff = new int[numlist.Length];
        int[] diffSort = new int[numlist.Length];

        for(int i = 0; i < numlist.Length; i++)
        {
            diff[i] = numlist[i] - n;
        }

        diffSort = (int[])diff.Clone();

        //버블정렬
        for(int i = 0; i < diffSort.Length - 1; i++)
        {
            bool isSwap = false;

            for (int j = 0; j < diffSort.Length - 1; j++)
            {
                if (diffSort[j] > diffSort[j + 1])
                {
                    int temp = diffSort[j];
                    diffSort[j] = diffSort[j + 1];
                    diffSort[j + 1] = temp;
                    isSwap = true;
                }
            }
            if(!isSwap)
            {
                break;
            }
        }

        //음수가 있으면 다시 정렬
        for (int i = 0; i < diffSort.Length - 1; i++)
        {
            bool isSwap = false;

            for (int j = 0; j < diffSort.Length - 1 - i; j++)
            {
                if (diffSort[j] < 0 && Math.Abs(diffSort[j]) >= Math.Abs(diffSort[j + 1]) )
                {
                    int temp = diffSort[j];
                    diffSort[j] = diffSort[j + 1];
                    diffSort[j + 1] = temp;
                    isSwap = true;
                }
            }
            if (!isSwap)
            {
                break;
            }
        }

        //값 넣기
        for(int i = 0; i < diff.Length; i++)
        {
            for(int j = 0; j < diffSort.Length; j++)
            {
                if (diffSort[j] == diff[i])
                {
                    answer[j] = numlist[i];
                    break;
                }
            }
        }

        return answer;
    }
}
```

---
**후기**
문제를 완벽히 이해하고 코드를 치고 큰 그림도 중요하지만 세세한 부분도 놓치지 말자